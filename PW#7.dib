#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №7.Реализация потока обработки команад.

**Цель:** Реализовать основу для многопоточного сервера приложений.

**Результаты:** После выполнения работы Вы сможете:
1. Обрабатывать множество операций в несколько потоков.
2. Останавливать потоки по запросу извне.

## Задание.
Пусть операция задана интерфейсом

#!csharp

public interface ICommand
{
    void Execute(); 
}

#!markdown

Классы, наследующие интерйес ICommand будем называть **Командами.**

Реализовать класс ServerThread и команды по hard и soft завершению потока. 

ServerThread может менять свое поведение для обработки следующей Команды.
Исключение, выброшенное из Команды, перехватывается и передается вместе с самой Командой в ExceptionHandler (см. ЛР №5) Примечание. Наличие реализованного обработчика исключений не обязательно для выполнения данной задачи. 

Команда HardStop приводит к немедленной остановке потока, несмотря на, что в очереди потока есть еще Команды.
Команда  SoftStop останавливает поток, когда в очереди потока закончатся все Команды.

Команды HardStop и SoftStop успешно выполняются только в потоке, который они должны остановить, в противном случае выбрасывают исключение.
Отсутствие Команд в очереди потока не должно требовать значительных затрат процессорного времени. Значительными считаются затраты, которые зависят от времени простоя потока.

Написать проверку, которая гарантирует правильное выполнение команд HardStop и SoftStop.

#!csharp

using System.Threading;
using System.Collections.Concurrent;

public class HardStopCommand : ICommand
{
    public ServerThread serverThread;

    public HardStopCommand(ServerThread serverThread)
    {
        this.serverThread = serverThread;
    }

    public void Execute()
    {
        if (Thread.CurrentThread != serverThread.thread) 
        throw new InvalidOperationException("HardStop должен выполняться только в потоке, который он должен остановить");

        serverThread.active = false;
    }
}
public class SoftStopCommand : ICommand
{
    public ServerThread serverThread;

    public SoftStopCommand(ServerThread serverThread)
    {
        this.serverThread = serverThread;
    }

    public void Execute()
    {
        if (Thread.CurrentThread != serverThread.thread) 
        throw new InvalidOperationException("SoftStop должен выполняться только в потоке, который он должен остановить");
        
        serverThread.sStopNeeded = true;
    }
}
public class RandomCommand : ICommand
{
    public void Execute()
    {
        Console.WriteLine("Что-то выполнилось");
    }
}

public class ExceptionCommand : ICommand
{
    public void Execute()
    {
        int x = 144; int y = 0;
        Console.WriteLine(x / y);
    }
}

public class ServerThread
{
    public Thread thread;
    public BlockingCollection<ICommand> commandQ;
    public bool active;
    public bool sStopNeeded;

    public ServerThread()
    {
        thread = new Thread(Run);
        commandQ = new BlockingCollection<ICommand>();
        active = true;
        sStopNeeded = false;
        thread.Start();
    }

    public void Run()
    {
        while (active)
        {
            if (commandQ.TryTake(out ICommand command))
            {
                try
                {
                    command.Execute();
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Возникло исключение: {ex.Message}");
                }
            }

            if (sStopNeeded && commandQ.Count == 0)
            {
                active = false;
            }
        }
    }
}

#!csharp

#r "nuget: xunit, 2.8.1"
using Xunit;

[Fact]
public void testSoftStop()
{
    ServerThread serverThread = new ServerThread();
    for (int i = 0; i < 5; i++)
    {
        serverThread.commandQ.Add(new RandomCommand());
    }
    serverThread.commandQ.Add(new SoftStopCommand(serverThread));
    serverThread.thread.Join();

    Assert.False(serverThread.active);
    Assert.True(serverThread.sStopNeeded && serverThread.commandQ.Count == 0);
}

[Fact]
public void testHardStop()
{
    ServerThread serverThread = new ServerThread();
    for (int i = 0; i < 5; i++)
    {
        serverThread.commandQ.Add(new RandomCommand());
    }
    serverThread.commandQ.Add(new HardStopCommand(serverThread));
    serverThread.thread.Join();

    Assert.False(serverThread.active);
}

[Fact]
public void testException()
{
    ServerThread serverThread = new ServerThread();
    serverThread.commandQ.Add(new ExceptionCommand());
    serverThread.commandQ.Add(new SoftStopCommand(serverThread));
    serverThread.thread.Join();
    Assert.False(serverThread.active);
    Assert.True(serverThread.sStopNeeded && serverThread.commandQ.Count == 0);
}
